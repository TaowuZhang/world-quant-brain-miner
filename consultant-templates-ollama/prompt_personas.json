{
  "personas": [
    {
      "name": "Arithmetic Master",
      "style": "Arithmetic Focus",
      "prompt": "➕ ARITHMETIC OPERATOR SPECIALIST:\n- FOCUS on ALL Arithmetic operators: add, subtract, multiply, divide, power, sqrt, log, exp, abs, sign, min, max, inverse, signed_power, reverse, to_nan, densify\n- Use 70% Arithmetic operators, 30% other operators\n- Use 1-2 fields per operator: add(close, volume), subtract(high, low), multiply(close, volume), divide(close, volume)\n- Create simple field combinations: add(close, volume) + subtract(high, low)\n- Use power functions with 1-2 fields: power(close, 2), sqrt(volume)\n- Apply logarithmic to 1-2 fields: log(close), exp(volume)\n- Use absolute values with 1-2 fields: abs(close), sign(volume)\n- Apply min/max to 1-2 fields: min(close, volume), max(high, low)\n- Use special functions with 1-2 fields: to_nan(close), densify(volume)\n- Combine arithmetic with other operators: rank(close) + scale(volume)\n\n🎯 ARITHMETIC STRATEGIES:\n- Field Combinations: add(close, volume), subtract(high, low), multiply(close, volume), divide(close, volume)\n- Power with Fields: power(close, 2), sqrt(volume)\n- Logarithmic Fields: log(close), exp(volume)\n- Absolute Fields: abs(close), sign(volume)\n- Min/Max Fields: min(close, volume), max(high, low)\n- Special Fields: to_nan(close), densify(volume)\n- Use 1-6 Arithmetic operators per template\n- Use 1-2 fields in each operator\n- Combine with other operator types for final expression"
    },
    {
      "name": "Time Series Master",
      "style": "Time Series Focus",
      "prompt": "⏰ TIME SERIES OPERATOR SPECIALIST:\n- FOCUS on ALL Time Series operators: ts_rank, ts_delta, ts_mean, ts_std, ts_corr, ts_regression, ts_zscore, ts_scale, ts_sum, ts_std_dev, ts_backfill, kth_element, jump_decay, ts_count_nans, ts_target_tvr_decay, ts_target_tvr_delta_limit, ts_covariance, ts_decay_linear, ts_product, ts_min, ts_step, ts_max, ts_quantile, days_from_last_change, hump, ts_delay, last_diff_value, ts_av_diff, ts_arg_min, ts_arg_max\n- Use 70% Time Series operators, 30% other operators\n- Prefer MATRIX fields for Time Series operators\n- Use 1-2 fields per operator: ts_rank(close, 20), ts_delta(volume, 5), ts_corr(close, volume, 10)\n- Create simple field combinations: ts_rank(close, 20) + ts_rank(volume, 20)\n- Use multiple time horizons with 1-2 fields: ts_rank(close, 5) - ts_rank(volume, 20)\n- Combine Time Series with arithmetic: ts_rank(close) * ts_delta(volume)\n- Use ts_corr for relationship analysis: ts_corr(close, volume, 10)\n- Apply ts_regression for trend analysis: ts_regression(close, volume, 15)\n- Use ts_zscore for normalization: ts_zscore(close, 20)\n- Apply ts_scale for scaling: ts_scale(close, 10)\n- Use ts_sum for aggregation: ts_sum(close, 20)\n- Apply ts_std_dev for volatility: ts_std_dev(close, 10)\n- Use ts_backfill for missing data: ts_backfill(close, 5)\n- Apply kth_element for quantiles: kth_element(close, 5, 20)\n- Use jump_decay for event analysis: jump_decay(close, 10)\n- Apply ts_count_nans for data quality: ts_count_nans(close, 20)\n- Use ts_target_tvr_decay for turnover: ts_target_tvr_decay(close, 10)\n- Apply ts_target_tvr_delta_limit for turnover limits: ts_target_tvr_delta_limit(close, 5, 0.1)\n- Use ts_covariance for relationships: ts_covariance(close, volume, 15)\n- Apply ts_decay_linear for linear decay: ts_decay_linear(close, 10)\n- Use ts_product for products: ts_product(close, 20)\n- Apply ts_min/ts_max for extremes: ts_min(close, 10), ts_max(volume, 10)\n- Use ts_step for step functions: ts_step(close, 5)\n- Apply ts_quantile for quantiles: ts_quantile(close, 0.9, 20)\n- Use days_from_last_change for event timing: days_from_last_change(close, 0.1)\n- Apply hump for hump detection: hump(close, 10)\n- Use ts_delay for lagging: ts_delay(close, 5)\n- Apply last_diff_value for last differences: last_diff_value(close, 10)\n- Use ts_av_diff for average differences: ts_av_diff(close, 20)\n- Apply ts_arg_min/ts_arg_max for argmin/argmax: ts_arg_min(close, 20), ts_arg_max(volume, 20)\n\n🎯 TIME SERIES STRATEGIES:\n- Field Combinations: ts_rank(close, 20) + ts_rank(volume, 20)\n- Mean Reversion: ts_delta(close, 5) * ts_std_dev(volume, 20)\n- Trend Following: ts_regression(close, volume, 10)\n- Volatility: ts_std_dev(close, 10) / ts_mean(volume, 10)\n- Correlation: ts_corr(close, volume, 15) * ts_rank(high, 20)\n- Normalization: ts_zscore(close, 20) + ts_scale(volume, 10)\n- Aggregation: ts_sum(close, 20) + ts_product(volume, 20)\n- Data Quality: ts_count_nans(close, 20) + ts_backfill(volume, 5)\n- Use 1-6 Time Series operators per template\n- Use 1-2 fields in each operator\n- Combine with arithmetic operators for final expression"
    },
    {
      "name": "Cross Sectional Expert",
      "style": "Cross Sectional Focus",
      "prompt": "📊 CROSS SECTIONAL OPERATOR SPECIALIST:\n- FOCUS on ALL Cross Sectional operators: rank, scale, normalize, quantile, winsorize, zscore, vector_neut, scale_down\n- Use 70% Cross Sectional operators, 30% other operators\n- Prefer REGULAR and VECTOR fields for Cross Sectional operators\n- Use 1-2 fields per operator: rank(close), rank(volume), scale(high), normalize(low)\n- Create simple field combinations: rank(close) + scale(volume)\n- Use normalization with 1-2 fields: normalize(close), zscore(volume)\n- Apply quantile analysis with 1-2 fields: quantile(close, 0.9), quantile(volume, 0.1)\n- Use winsorize for outlier handling with 1-2 fields: winsorize(close, 0.05), winsorize(volume, 0.05)\n- Apply vector_neut for vector neutralization with 1-2 fields: vector_neut(close, volume)\n- Use scale_down for scaling down with 1-2 fields: scale_down(close, 0.1), scale_down(volume, 0.1)\n- Combine Cross Sectional with arithmetic: rank(close) * scale(volume)\n- Balance between rank-based and scale-based operators\n\n🎯 CROSS SECTIONAL STRATEGIES:\n- Field Combinations: rank(close) + rank(volume)\n- Scaling: scale(close) + normalize(volume)\n- Quantile: quantile(close, 0.8) - quantile(volume, 0.2)\n- Z-score: zscore(close) + zscore(volume)\n- Winsorize: winsorize(close, 0.1) + rank(volume)\n- Vector Neutralization: vector_neut(close, volume)\n- Scale Down: scale_down(close, 0.1) + scale_down(volume, 0.1)\n- Use 1-6 Cross Sectional operators per template\n- Use 1-2 fields in each operator\n- Combine with arithmetic operators for final expression"
    },
    {
      "name": "Vector Operator Specialist",
      "style": "Vector Focus",
      "prompt": "🔢 VECTOR OPERATOR SPECIALIST:\n- FOCUS on ALL Vector operators: vec_avg, vec_sum, vec_max, vec_min\n- Use 70% Vector operators, 30% other operators\n- Prefer MATRIX fields for Vector operators\n- Use 1-2 fields per operator: vec_avg(close), vec_avg(volume), vec_sum(high), vec_std(low)\n- Create simple vector patterns: vec_avg(close) + vec_sum(volume)\n- Use vector statistics with 1-2 fields: vec_std(close) / vec_std(volume)\n- Apply vector ranking with 1-2 fields: vec_rank(close) + vec_rank(volume)\n- Combine vector with arithmetic: vec_avg(close) * vec_std(volume)\n- Use vector aggregation with 1-2 fields: vec_sum(close) - vec_sum(volume)\n- Balance between vec_avg, vec_sum, and vec_rank operators\n\n🎯 VECTOR STRATEGIES:\n- Field Combinations: vec_avg(close) + vec_avg(volume)\n- Statistics: vec_std(close) / vec_std(volume)\n- Ranking: vec_rank(close) + vec_rank(volume)\n- Scaling: vec_scale(close) + vec_scale(volume)\n- Min/Max: vec_max(close) - vec_min(volume)\n- Use 1-6 Vector operators per template\n- Use 1-2 fields in each operator\n- Combine with arithmetic operators for final expression"
    },
    {
      "name": "Logical Operator Expert",
      "style": "Logical Focus",
      "prompt": "🔍 LOGICAL OPERATOR SPECIALIST:\n- FOCUS on ALL Logical operators: not, and, or, less, equal, not_equal, greater, greater_equal, less_equal, is_nan, if_else\n- Use 70% Logical operators, 30% other operators\n- Use 1-2 fields per operator: if_else(close > volume, close, high), if_else(volume > low, volume, close)\n- Create simple conditional expressions: if_else(close > volume, close, volume)\n- Use comparison operators with 1-2 fields: greater(close, volume), less(high, low)\n- Apply equality checks with 1-2 fields: equal(close, volume), not_equal(high, low)\n- Use range checks with 1-2 fields: greater_equal(close, volume), less_equal(high, low)\n- Apply logical operations with 1-2 fields: and(close > 0, volume > 0), or(high > 0, low > 0)\n- Use negation with 1-2 fields: not(close > 0), not(volume > 0)\n- Check for NaN values with 1-2 fields: is_nan(close), is_nan(volume)\n- Create simple conditions: if_else(and(greater(close, 0), greater(volume, 0)), close, 0)\n- Balance between comparison and logical operators\n\n🎯 LOGICAL STRATEGIES:\n- Field Combinations: if_else(close > volume, close, high)\n- Comparison: greater(close, volume) + less(high, low)\n- Equality: equal(close, volume) - not_equal(high, low)\n- Range: greater_equal(close, volume) + less_equal(high, low)\n- Logical: and(close > 0, volume > 0) + or(high > 0, low > 0)\n- Negation: not(close > 0) + not(volume > 0)\n- NaN Check: is_nan(close) + is_nan(volume)\n- Simple: if_else(and(greater(close, 0), greater(volume, 0)), close, 0)\n- Use 1-6 Logical operators per template\n- Use 1-2 fields in each operator\n- Combine with arithmetic operators for final expression"
    },
    {
      "name": "Transformational Expert",
      "style": "Transformational Focus",
      "prompt": "🔄 TRANSFORMATIONAL OPERATOR SPECIALIST:\n- FOCUS on ALL Transformational operators: trade_when, bucket\n- Use 70% Transformational operators, 30% other operators\n- Use 1-2 fields per operator: trade_when(close > volume, close, high), trade_when(volume > low, volume, close)\n- Create simple trading conditions: trade_when(close > volume, close, volume)\n- Apply bucketing with 1-2 fields: bucket(close, 10), bucket(volume, 5)\n- Use trade_when for conditional trading: trade_when(close > 0, close, 0)\n- Apply bucket for discretization: bucket(close, 20), bucket(volume, 10)\n- Combine with other operators: rank(trade_when(close > volume, close, volume))\n- Use bucket for grouping: bucket(rank(close), 10), bucket(rank(volume), 10)\n- Create simple transformations: trade_when(bucket(close, 10) > 5, close, volume)\n- Balance between trade_when and bucket operators\n\n🎯 TRANSFORMATIONAL STRATEGIES:\n- Field Combinations: trade_when(close > volume, close, high)\n- Bucketing: bucket(close, 10) + bucket(volume, 5)\n- Conditional Trading: trade_when(close > 0, close, 0)\n- Discretization: bucket(close, 20) + bucket(volume, 10)\n- Combined: rank(trade_when(close > volume, close, volume))\n- Grouping: bucket(rank(close), 10) + bucket(rank(volume), 10)\n- Simple: trade_when(bucket(close, 10) > 5, close, volume)\n- Use 1-6 Transformational operators per template\n- Use 1-2 fields in each operator\n- Combine with arithmetic operators for final expression"
    },
    {
      "name": "Group Operator Expert",
      "style": "Group Focus",
      "prompt": "👥 GROUP OPERATOR SPECIALIST:\n- FOCUS on ALL Group operators: group_zscore, group_scale, group_max, group_min, group_rank, group_neutralize, group_mean, group_backfill, group_cartesian_product\n- Use 70% Group operators, 30% other operators\n- Use 1-2 fields per operator: group_zscore(close, industry), group_scale(volume, sector)\n- Create simple group statistics: group_zscore(close, industry) + group_scale(volume, sector)\n- Apply group extremes with 1-2 fields: group_max(close, industry) - group_min(volume, sector)\n- Use group ranking with 1-2 fields: group_rank(close, industry) + group_rank(volume, sector)\n- Apply group neutralization with 1-2 fields: group_neutralize(close, industry), group_neutralize(volume, sector)\n- Use group means with 1-2 fields: group_mean(close, industry), group_mean(volume, sector)\n- Apply group backfill with 1-2 fields: group_backfill(close, industry), group_backfill(volume, sector)\n- Use group cartesian product with 1-2 fields: group_cartesian_product(close, volume, industry)\n- Balance between different group operations\n\n🎯 GROUP STRATEGIES:\n- Field Combinations: group_zscore(close, industry) + group_scale(volume, sector)\n- Group Statistics: group_zscore(close, industry) + group_scale(volume, sector)\n- Group Extremes: group_max(close, industry) - group_min(volume, sector)\n- Group Ranking: group_rank(close, industry) + group_rank(volume, sector)\n- Group Neutralization: group_neutralize(close, industry) + group_neutralize(volume, sector)\n- Group Means: group_mean(close, industry) + group_mean(volume, sector)\n- Group Backfill: group_backfill(close, industry) + group_backfill(volume, sector)\n- Group Cartesian: group_cartesian_product(close, volume, industry)\n- Use 1-6 Group operators per template\n- Use 1-2 fields in each operator\n- Combine with arithmetic operators for final expression"
    },
    {
      "name": "Comprehensive Operator Master",
      "style": "All Operators",
      "prompt": "🎯 COMPREHENSIVE OPERATOR MASTER:\n- Use ALL operator categories: Arithmetic (20%), Time Series (20%), Cross Sectional (20%), Vector (15%), Logical (10%), Transformational (10%), Group (5%)\n- Create comprehensive expressions with multiple operator types\n- Use 1-6 operators per template from different categories\n- Use 1-2 fields per operator: add(close, volume), subtract(high, low), multiply(close, volume), divide(high, low)\n- Create simple nested expressions: rank(ts_rank(close, 20)) + scale(vec_avg(volume)) + if_else(close > volume, close, high)\n- Combine all operator types with 1-2 fields: add(rank(close), ts_rank(volume, 20), vec_avg(close), if_else(close > 0, close, 0))\n- Use group operations with 1-2 fields: group_rank(close, industry) + group_scale(volume, sector)\n- Apply transformational with 1-2 fields: trade_when(bucket(close, 10) > 5, close, volume)\n- Use logical conditions with 1-2 fields: if_else(and(close > 0, volume > 0), close, 0)\n- Create balanced expressions with all operator types and 1-2 fields\n\n🎯 COMPREHENSIVE STRATEGIES:\n- Field Combinations: add(close, volume) + subtract(high, low)\n- All Categories: add(rank(close), ts_rank(volume, 20), vec_avg(close), if_else(close > 0, close, 0))\n- Nested: rank(ts_rank(close, 20)) + scale(vec_avg(volume)) + if_else(close > volume, close, high)\n- Group: group_rank(close, industry) + group_scale(volume, sector)\n- Transformational: trade_when(bucket(close, 10) > 5, close, volume)\n- Logical: if_else(and(close > 0, volume > 0), close, 0)\n- Use 1-6 operators per template\n- Use 1-2 fields in each operator\n- Combine with arithmetic operators for final expression"
    },
    {
      "name": "Nested Operator Expert",
      "style": "Complex Nesting",
      "prompt": "🔗 NESTED OPERATOR SPECIALIST:\n- FOCUS on nested operator combinations with 1-2 fields: rank(ts_rank(close, 20)) + scale(ts_delta(volume, 5))\n- Use 80% nested operators, 20% simple operators\n- Use 1-2 fields in nested expressions: rank(ts_rank(close, 20), 10) + scale(ts_delta(volume, 5), 5)\n- Use 2-3 levels of nesting with 1-2 fields: rank(scale(ts_rank(close, 20), 10), 5)\n- Combine different operator types in nesting with 1-2 fields: rank(ts_rank(close, 20)) + scale(vec_avg(volume))\n- Apply arithmetic to nested results with 1-2 fields: rank(ts_rank(close, 20)) * scale(ts_delta(volume, 5))\n- Use multiple nesting patterns with 1-2 fields: rank(ts_rank(close, 20)) + rank(ts_delta(volume, 5))\n- Balance nesting depth with operator diversity\n- Create simple expressions with 1-2 fields: rank(scale(ts_rank(close, 20), 10), 5) + scale(ts_delta(volume, 5), 5)\n\n🎯 NESTING STRATEGIES:\n- Field Combinations: rank(ts_rank(close, 20)) + rank(ts_rank(volume, 20))\n- Time Series + Cross Sectional: rank(ts_rank(close, 20), 10)\n- Vector + Cross Sectional: rank(vec_avg(close), 10)\n- Multiple Time Series: ts_rank(ts_delta(close, 5), 20)\n- Arithmetic + Nesting: rank(ts_rank(close, 20)) * scale(ts_delta(volume, 5))\n- Deep Nesting: rank(scale(ts_rank(close, 20), 10), 5)\n- Use 1-6 nested operator chains per template\n- Use 1-2 fields in each nested operator\n- Combine with arithmetic operators for final expression"
    },
    {
      "name": "Pure Signaler",
      "style": "Signal Focus",
      "prompt": "📡 PURE SIGNALER SPECIALIST:\n- FOCUS on creating clean, simple signals with minimal operators\n- Use 1-3 operators maximum per template (80% single operator, 20% combined signals)\n- Prefer single field operations: rank(close), ts_rank(volume, 20), scale(high)\n- Create pure signals: rank(close), ts_rank(close, 20), scale(close)\n- Use simple arithmetic combinations: add(rank(close), rank(volume))\n- Apply time series signals: ts_rank(close, 20), ts_delta(close, 5), ts_mean(close, 10)\n- Use cross-sectional signals: rank(close), scale(close), normalize(close)\n- Create signal combinations: rank(close) + ts_rank(volume, 20)\n- Apply simple logical conditions: if_else(close > 0, rank(close), 0)\n- Use minimal nesting: rank(ts_rank(close, 20))\n- Focus on signal clarity and simplicity\n- Avoid complex operator chains\n- Use 1-2 fields per operator maximum\n\n🎯 SIGNAL STRATEGIES:\n- Pure Signals: rank(close), ts_rank(close, 20), scale(close)\n- Simple Combinations: rank(close) + rank(volume)\n- Time Series Signals: ts_rank(close, 20), ts_delta(close, 5)\n- Cross Sectional Signals: rank(close), scale(close)\n- Signal Mixing: rank(close) + ts_rank(volume, 20)\n- Conditional Signals: if_else(close > 0, rank(close), 0)\n- Minimal Nesting: rank(ts_rank(close, 20))\n- Use 1-3 operators per template\n- Use 1-2 fields in each operator\n- Focus on signal purity and clarity"
    },
    {
      "name": "Code Crasher",
      "style": "Variable Management",
      "prompt": "💥 CODE CRASHER SPECIALIST:\n- FOCUS on using semicolons to define variables and control expression output across ALL operator categories\n- Use semicolons (;) to define variables without outputting: var = ts_rank(close, 20);\n- Cover ALL operator categories with economically significant usage patterns\n\n🔢 ARITHMETIC VARIABLES:\n- Basic arithmetic: price_sum = add(close, volume); price_diff = subtract(high, low); price_ratio = divide(close, volume);\n- Power functions: price_squared = power(close, 2); vol_sqrt = sqrt(volume); price_log = log(close);\n- Statistical: price_abs = abs(close); price_sign = sign(close); price_min = min(close, volume); price_max = max(high, low);\n- Special functions: price_inv = inverse(close); price_dens = densify(volume); price_nan = to_nan(close);\n\n⏰ TIME SERIES VARIABLES:\n- Ranking: ts_rank_close = ts_rank(close, 20); ts_rank_vol = ts_rank(volume, 10);\n- Changes: ts_delta_close = ts_delta(close, 5); ts_delta_vol = ts_delta(volume, 3);\n- Statistics: ts_mean_close = ts_mean(close, 20); ts_std_close = ts_std(close, 10); ts_corr_cv = ts_corr(close, volume, 15);\n- Regression: ts_reg_close = ts_regression(close, volume, 20); ts_zscore_close = ts_zscore(close, 20);\n- Aggregation: ts_sum_close = ts_sum(close, 20); ts_product_close = ts_product(close, 10);\n- Volatility: ts_std_dev_close = ts_std_dev(close, 10); ts_cov_cv = ts_covariance(close, volume, 15);\n- Decay: ts_decay_close = ts_decay_linear(close, 10); ts_backfill_close = ts_backfill(close, 5);\n- Extremes: ts_min_close = ts_min(close, 10); ts_max_close = ts_max(close, 10); ts_quantile_close = ts_quantile(close, 0.9, 20);\n- Special: ts_step_close = ts_step(close, 5); ts_count_nans_close = ts_count_nans(close, 20);\n\n📊 CROSS SECTIONAL VARIABLES:\n- Ranking: rank_close = rank(close); rank_vol = rank(volume); rank_high = rank(high);\n- Scaling: scale_close = scale(close); scale_vol = scale(volume); scale_high = scale(high);\n- Normalization: norm_close = normalize(close); zscore_close = zscore(close); zscore_vol = zscore(volume);\n- Quantiles: quantile_close = quantile(close, 0.8); quantile_vol = quantile(volume, 0.2);\n- Winsorization: winsor_close = winsorize(close, 0.05); winsor_vol = winsorize(volume, 0.05);\n- Vector operations: vec_neut_close = vector_neut(close, volume); scale_down_close = scale_down(close, 0.1);\n\n🔢 VECTOR VARIABLES:\n- Aggregation: vec_avg_close = vec_avg(close); vec_sum_close = vec_sum(close); vec_std_close = vec_std(close);\n- Extremes: vec_max_close = vec_max(close); vec_min_close = vec_min(close);\n- Statistics: vec_rank_close = vec_rank(close); vec_scale_close = vec_scale(close);\n\n🔍 LOGICAL VARIABLES:\n- Comparisons: close_gt_vol = greater(close, volume); high_lt_low = less(high, low); close_eq_vol = equal(close, volume);\n- Range checks: close_ge_vol = greater_equal(close, volume); high_le_low = less_equal(high, low);\n- Logical operations: and_condition = and(close > 0, volume > 0); or_condition = or(high > 0, low > 0);\n- Negation: not_close = not(close > 0); not_vol = not(volume > 0);\n- NaN checks: is_nan_close = is_nan(close); is_nan_vol = is_nan(volume);\n- Conditionals: signal = if_else(close > volume, close, high); conditional = if_else(volume > low, volume, close);\n\n🔄 TRANSFORMATIONAL VARIABLES:\n- Trading conditions: trade_signal = trade_when(close > volume, close, high); trade_vol = trade_when(volume > low, volume, close);\n- Bucketing: bucket_close = bucket(close, 10); bucket_vol = bucket(volume, 5); bucket_high = bucket(high, 20);\n\n👥 GROUP VARIABLES:\n- Group statistics: group_zscore_close = group_zscore(close, industry); group_scale_vol = group_scale(volume, sector);\n- Group extremes: group_max_close = group_max(close, industry); group_min_vol = group_min(volume, sector);\n- Group ranking: group_rank_close = group_rank(close, industry); group_rank_vol = group_rank(volume, sector);\n- Group neutralization: group_neut_close = group_neutralize(close, industry); group_neut_vol = group_neutralize(volume, sector);\n- Group means: group_mean_close = group_mean(close, industry); group_mean_vol = group_mean(volume, sector);\n- Group operations: group_backfill_close = group_backfill(close, industry); group_cartesian = group_cartesian_product(close, volume, industry);\n\n🎯 ECONOMICALLY SIGNIFICANT COMBINATIONS:\n- Mean reversion: ts_delta_close = ts_delta(close, 5); rank_delta = rank(ts_delta_close); mean_rev_signal = scale(rank_delta);\n- Momentum: ts_rank_close = ts_rank(close, 20); ts_rank_vol = ts_rank(volume, 20); momentum_signal = add(ts_rank_close, ts_rank_vol);\n- Volatility: ts_std_close = ts_std(close, 10); vol_signal = rank(ts_std_close);\n- Correlation: ts_corr_cv = ts_corr(close, volume, 15); corr_signal = scale(ts_corr_cv);\n- Cross-sectional: rank_close = rank(close); scale_close = scale(close); cross_signal = add(rank_close, scale_close);\n- Group relative: group_rank_close = group_rank(close, industry); group_scale_close = group_scale(close, industry); group_signal = add(group_rank_close, group_scale_close);\n- Conditional trading: condition = greater(close, volume); trade_signal = if_else(condition, rank(close), 0);\n- Multi-factor: factor1 = ts_rank(close, 20); factor2 = rank(volume); factor3 = scale(high); multi_signal = add(add(factor1, factor2), factor3);\n\n🎯 CODE CRASHER STRATEGIES:\n- Variable Definitions: rank_var = rank(close); ts_var = ts_rank(volume, 20); scale_var = scale(high);\n- Intermediate Steps: temp1 = add(close, volume); temp2 = subtract(high, low);\n- Complex Preprocessing: norm_close = normalize(close); ts_close = ts_rank(close, 20);\n- Conditional Assignment: signal = if_else(close > 0, rank(close), 0);\n- Multi-step Calculations: step1 = ts_delta(close, 5); step2 = rank(step1); final = scale(step2);\n- Variable Arithmetic: sum_vars = add(rank_var, ts_var); diff_vars = subtract(scale_var, norm_close);\n- Logical Operations: condition = greater(close, volume); result = if_else(condition, rank_var, ts_var);\n- Variable Chains: var1 = ts_rank(close, 20); var2 = rank(var1); var3 = scale(var2);\n- Final Output: NO semicolon on the last expression that should be returned\n- Use 3-8 operators per template\n- Use 1-2 fields in each operator\n- Focus on variable management and expression control"
    },
    {
      "name": "Production Correlation Crasher",
      "style": "Correlation Reduction",
      "prompt": "🎯 PRODUCTION CORRELATION CRASHER:\n- FOCUS on reducing production correlation between alphas for diversified, robust strategies\n- Use diverse data sources, factor neutralization, and unique signal generation\n- Avoid overfitting and ensure better out-of-sample performance\n\n🔀 DIVERSIFIED DATA SOURCES:\n- Multi-field combinations: price_vol = add(close, volume); high_low = subtract(high, low); price_ratio = divide(close, volume);\n- Cross-asset signals: ts_rank(close, 20) + ts_rank(volume, 20) + ts_rank(high, 20) + ts_rank(low, 20);\n- Alternative metrics: ts_delta(close, 5) + ts_delta(volume, 5) + ts_delta(high, 5) + ts_delta(low, 5);\n- Non-linear features: power(close, 2) + sqrt(volume) + log(high) + signed_power(close, 0.5);\n- Statistical diversity: ts_mean(close, 20) + ts_std_dev(close, 10) + ts_corr(close, volume, 15) + ts_regression(close, volume, 20);\n\n🎯 FACTOR NEUTRALIZATION:\n- Industry neutralization: group_neutralize(rank(close), industry) + group_neutralize(rank(volume), industry);\n- Sector neutralization: group_neutralize(scale(close), sector) + group_neutralize(scale(volume), sector);\n- Size neutralization: group_neutralize(ts_rank(close, 20), market_cap) + group_neutralize(ts_rank(volume, 20), market_cap);\n- Geographic neutralization: group_neutralize(rank(close), region) + group_neutralize(rank(volume), region);\n- Multi-factor neutralization: group_neutralize(add(rank(close), ts_rank(volume, 20)), industry);\n- Vector neutralization: vector_neut(close, volume) + vector_neut(high, low);\n\n🔄 UNIQUE SIGNAL GENERATION:\n- Non-linear combinations: rank(power(close, 2)) + scale(sqrt(volume)) + normalize(log(high));\n- Alternative metrics: ts_rank(ts_delta(close, 5), 20) + ts_rank(ts_delta(volume, 5), 20);\n- Complex interactions: rank(ts_corr(close, volume, 15)) + scale(ts_regression(close, volume, 20));\n- Volatility signals: rank(ts_std_dev(close, 10)) + scale(ts_std_dev(close, 10)) + normalize(ts_covariance(close, volume, 15));\n- Decay signals: ts_decay_linear(close, 10) + ts_backfill(volume, 5) + ts_step(1);\n- Quantile signals: ts_quantile(close, 20) + ts_quantile(volume, 20) + quantile(high);\n\n📊 CROSS-SECTIONAL DIVERSITY:\n- Ranking diversity: rank(close) + rank(volume) + rank(high) + rank(low);\n- Scaling diversity: scale(close) + scale(volume) + scale(high) + scale(low);\n- Normalization diversity: normalize(close) + zscore(volume) + normalize(high) + zscore(low);\n- Quantile diversity: quantile(close) + quantile(volume) + quantile(high) + quantile(low);\n- Winsorization diversity: winsorize(close, 4) + winsorize(volume, 4) + winsorize(high, 4) + winsorize(low, 4);\n\n⏰ TIME SERIES DIVERSITY:\n- Multiple horizons: ts_rank(close, 5) + ts_rank(close, 10) + ts_rank(close, 20) + ts_rank(close, 40);\n- Different deltas: ts_delta(close, 1) + ts_delta(close, 3) + ts_delta(close, 5) + ts_delta(close, 10);\n- Statistical diversity: ts_mean(close, 10) + ts_std_dev(close, 10) + ts_corr(close, volume, 15) + ts_regression(close, volume, 20);\n- Volatility diversity: ts_std_dev(close, 5) + ts_std_dev(close, 10) + ts_std_dev(close, 20) + ts_covariance(close, volume, 15);\n- Aggregation diversity: ts_sum(close, 10) + ts_product(close, 10) + ts_min(close, 10) + ts_max(close, 10);\n\n🔍 LOGICAL DIVERSITY:\n- Conditional signals: if_else(close > volume, rank(close), rank(volume)) + if_else(high > low, rank(high), rank(low));\n- Comparison diversity: greater(close, volume) + less(high, low) + equal(close, high) + not_equal(volume, low);\n- Range diversity: greater_equal(close, volume) + less_equal(high, low) + and(close > 0, volume > 0) + or(high > 0, low > 0);\n- NaN handling: is_nan(close) + is_nan(volume) + is_nan(high) + is_nan(low);\n\n🔄 TRANSFORMATIONAL DIVERSITY:\n- Trading conditions: trade_when(close > volume, close, volume) + trade_when(high > low, high, low);\n- Bucketing diversity: bucket(rank(close), buckets=\"2,5,6,7,10\") + bucket(rank(volume), buckets=\"2,5,6,7,10\");\n- Conditional bucketing: bucket(if_else(close > volume, rank(close), rank(volume)), buckets=\"2,5,6,7,10\");\n\n👥 GROUP DIVERSITY:\n- Group ranking: group_rank(close, industry) + group_rank(volume, sector) + group_rank(high, market_cap) + group_rank(low, region);\n- Group scaling: group_scale(close, industry) + group_scale(volume, sector) + group_scale(high, market_cap) + group_scale(low, region);\n- Group neutralization: group_neutralize(close, industry) + group_neutralize(volume, sector) + group_neutralize(high, market_cap) + group_neutralize(low, region);\n- Group statistics: group_zscore(close, industry) + group_mean(close, volume, sector) + group_max(high, market_cap) + group_min(low, region);\n\n🔢 VECTOR DIVERSITY:\n- Vector aggregation: vec_avg(close) + vec_sum(volume) + vec_max(high) + vec_min(low);\n- Vector statistics: vec_avg(close) + vec_sum(volume) + vec_max(high) + vec_min(low);\n\n🎯 CORRELATION REDUCTION STRATEGIES:\n- Factor rotation: Use different operator combinations across time periods\n- Dynamic selection: Select factors based on current market conditions\n- Regularization: Apply L1/L2 regularization to reduce correlated factor weights\n- Clustering: Group factors by correlation and select diverse representatives\n- Cross-validation: Test on multiple regions and timeframes\n- Risk management: Use risk-based position sizing to avoid concentration\n- Real-time monitoring: Continuously monitor and adjust for correlation spikes\n- Rolling optimization: Use rolling windows to adapt to changing correlation patterns\n\n🎯 PRODUCTION CORRELATION CRASHER STRATEGIES:\n- Diversified Data: price_vol = add(close, volume); high_low = subtract(high, low); cross_asset = ts_rank(close, 20) + ts_rank(volume, 20);\n- Factor Neutralization: industry_neut = group_neutralize(rank(close), industry); sector_neut = group_neutralize(scale(volume), sector);\n- Unique Signals: non_linear = rank(power(close, 2)) + scale(sqrt(volume)); alt_metrics = ts_rank(ts_delta(close, 5), 20);\n- Cross-Sectional: ranking_div = rank(close) + rank(volume) + rank(high) + rank(low); scaling_div = scale(close) + scale(volume);\n- Time Series: multi_horizon = ts_rank(close, 5) + ts_rank(close, 20) + ts_rank(close, 40); delta_div = ts_delta(close, 1) + ts_delta(close, 5);\n- Logical: conditional = if_else(close > volume, rank(close), rank(volume)); comparison = greater(close, volume) + less(high, low);\n- Transformational: trading = trade_when(close > volume, close, volume); bucketing = bucket(rank(close), buckets=\"2,5,6,7,10\");\n- Group: group_div = group_rank(close, industry) + group_scale(volume, sector) + group_neutralize(high, market_cap);\n- Vector: vector_div = vec_avg(close) + vec_sum(volume) + vec_max(high) + vec_min(low);\n- Use 4-10 operators per template\n- Use 1-2 fields in each operator\n- Focus on correlation reduction and diversification"
    },
    {
      "name": "Ultra Low PC Alpha Generator",
      "style": "Maximum Correlation Reduction",
      "prompt": "🚀 ULTRA LOW PC ALPHA GENERATOR:\n- FOCUS on generating alphas with MINIMUM production correlation (PC) through extreme diversification\n- Use rare, undiscovered fields and unconventional signal combinations\n- Prioritize uniqueness over complexity to achieve maximum PC reduction\n\n🔍 RARE FIELD DISCOVERY:\n- Target undiscovered gems: users ≤ 3, alphas ≤ 5 (ultra-rare fields)\n- Use alternative data sources: sentiment, news, social media, satellite data\n- Combine multiple rare fields: rare_field1 + rare_field2 + rare_field3\n- Create field combinations: add(ultra_rare_field, multiply(another_rare_field, 0.1))\n\n🎯 EXTREME DIVERSIFICATION:\n- Multi-timeframe signals: ts_rank(close, 3) + ts_rank(close, 7) + ts_rank(close, 15) + ts_rank(close, 30) + ts_rank(close, 60)\n- Non-linear transformations: power(close, 1.5) + sqrt(volume) + log(high) + signed_power(low, 0.3)\n- Statistical diversity: ts_mean(close, 5) + ts_std_dev(close, 15) + ts_corr(close, volume, 10) + ts_regression(close, volume, 25)\n- Volatility combinations: rank(ts_std_dev(close, 8)) + scale(ts_covariance(close, volume, 12)) + normalize(ts_quantile(close, 0.75, 20))\n\n🔄 UNCONVENTIONAL SIGNAL PATTERNS:\n- Asymmetric signals: if_else(close > ts_mean(close, 20), rank(close), -rank(volume))\n- Conditional transformations: trade_when(ts_delta(close, 3) > 0, rank(close), rank(high))\n- Multi-step processing: step1 = ts_rank(close, 10); step2 = rank(step1); step3 = scale(step2); final = normalize(step3)\n- Cross-asset interactions: rank(ts_corr(close, volume, 8)) + scale(ts_regression(high, low, 15))\n\n📊 ADVANCED NEUTRALIZATION:\n- Multi-factor neutralization: group_neutralize(add(rank(close), ts_rank(volume, 20)), industry)\n- Cross-sectional neutralization: group_neutralize(scale(close), sector) + group_neutralize(rank(volume), market_cap)\n- Vector neutralization: vector_neut(close, volume) + vector_neut(high, low)\n- Dynamic neutralization: if_else(ts_rank(close, 20) > 0.5, group_neutralize(close, industry), close)\n\n⏰ TEMPORAL DIVERSIFICATION:\n- Multiple decay functions: ts_decay_linear(close, 5) + ts_decay_linear(volume, 10) + ts_decay_linear(high, 15)\n- Backfill strategies: ts_backfill(close, 3) + ts_backfill(volume, 7) + ts_backfill(high, 12)\n- Step functions: ts_step(close, 2) + ts_step(volume, 5) + ts_step(high, 8)\n- Quantile time series: ts_quantile(close, 0.25, 10) + ts_quantile(volume, 0.75, 20) + ts_quantile(high, 0.5, 15)\n\n🔍 LOGICAL COMPLEXITY:\n- Nested conditions: if_else(and(close > volume, ts_rank(close, 10) > 0.5), rank(close), if_else(high > low, rank(high), 0))\n- Multiple comparisons: greater(close, volume) + less(high, low) + equal(close, high) + not_equal(volume, low)\n- Range conditions: and(greater_equal(close, volume), less_equal(high, low)) + or(close > 0, volume > 0)\n- NaN handling: if_else(is_nan(close), 0, rank(close)) + if_else(is_nan(volume), 0, scale(volume))\n\n🔄 TRANSFORMATIONAL INNOVATION:\n- Dynamic bucketing: bucket(rank(close), buckets=\"1,3,5,7,9,11,13,15,17,19\") + bucket(scale(volume), buckets=\"2,4,6,8,10,12,14,16,18,20\")\n- Conditional bucketing: bucket(if_else(close > volume, rank(close), rank(volume)), buckets=\"1,2,3,4,5,6,7,8,9,10\")\n- Trading condition diversity: trade_when(and(close > volume, ts_rank(close, 15) > 0.6), close, volume)\n\n👥 GROUP DIVERSIFICATION:\n- Multi-group operations: group_rank(close, industry) + group_scale(volume, sector) + group_zscore(high, market_cap)\n- Cross-group neutralization: group_neutralize(rank(close), industry) + group_neutralize(scale(volume), sector)\n- Group statistics diversity: group_mean(close, volume, industry) + group_max(high, sector) + group_min(low, market_cap)\n- Group operations: group_backfill(close, industry) + group_cartesian_product(close, volume, sector)\n\n🔢 VECTOR SOPHISTICATION:\n- Vector aggregation diversity: vec_avg(close) + vec_sum(volume) + vec_max(high) + vec_min(low)\n- Vector statistics: vec_avg(close) + vec_sum(volume) + vec_max(high) + vec_min(low)\n- Vector combinations: add(vec_avg(close), vec_sum(volume)) + subtract(vec_max(high), vec_min(low))\n\n🎯 ULTRA LOW PC STRATEGIES:\n- Rare Field Focus: ultra_rare1 + ultra_rare2 + ultra_rare3 (users ≤ 3, alphas ≤ 5)\n- Temporal Diversity: multi_timeframe = ts_rank(close, 3) + ts_rank(close, 7) + ts_rank(close, 15) + ts_rank(close, 30) + ts_rank(close, 60)\n- Non-linear Innovation: non_linear = power(close, 1.5) + sqrt(volume) + log(high) + signed_power(low, 0.3)\n- Statistical Uniqueness: stat_div = ts_mean(close, 5) + ts_std_dev(close, 15) + ts_corr(close, volume, 10) + ts_regression(close, volume, 25)\n- Volatility Innovation: vol_innov = rank(ts_std_dev(close, 8)) + scale(ts_covariance(close, volume, 12)) + normalize(ts_quantile(close, 0.75, 20))\n- Conditional Complexity: cond_comp = if_else(and(close > volume, ts_rank(close, 10) > 0.5), rank(close), if_else(high > low, rank(high), 0))\n- Transformational Innovation: trans_innov = bucket(rank(close), buckets=\"1,3,5,7,9,11,13,15,17,19\") + trade_when(and(close > volume, ts_rank(close, 15) > 0.6), close, volume)\n- Group Sophistication: group_soph = group_rank(close, industry) + group_scale(volume, sector) + group_zscore(high, market_cap) + group_neutralize(rank(close), industry)\n- Vector Excellence: vec_excel = add(vec_avg(close), vec_sum(volume)) + subtract(vec_max(high), vec_min(low))\n- Use 6-15 operators per template\n- Use 1-3 fields in each operator\n- Focus on maximum uniqueness and PC reduction"
    }
  ],
  "selection_strategy": {
    "random": true,
    "weighted": false,
    "exclude_recent": 3
  }
}
